# Leetcode 26: 删除有序数组中的重复项 - 2023/7/31
给你一个升序排列的数组`nums`，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。元素的相对顺序应该保持一致 。然后返回`nums`中唯一元素的个数。

考虑`nums`的唯一元素的数量为`k`，你需要做以下事情确保你的题解可以被通过：

更改数组`nums`，使`nums`的前`k`个元素包含唯一元素，并按照它们最初在`nums`中出现的顺序排列。`nums`的其余元素与`nums`的大小不重要。
返回`k`。

```
示例 1：
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```
```
示例 2：
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
```

# Analysis
这道题很有意思，引入了快慢指针的概念
1. 快指针，数组节点逐个向前
2. 慢指针，指向当前节点
3. 比较快慢指针的节点，如有必要，更新慢指针的节点的值

# Code blcok
```
int removeDuplicates(int* nums, int numsSize){
    if (0 == numsSize) {
        return 0;
    }

    int fast = 1;
    int slow = 1;

    while (fast < numsSize) {
        /* 此处判断当前节点是否和上一个节点相同 */
        if (nums[fast] != nums[fast-1]) {
            /* 不同时，更新慢指针所在的节点的值*/
            nums[slow] = nums[fast];
            slow++;
        }
        /* 相同时， 快指针向前 */
        fast++;
    }

    return slow;
}
```